{"file_contents":{"app.py":{"content":"import streamlit as st\nimport pandas as pd\nimport os\nfrom utils.email_validator import EmailValidator\nfrom utils.email_sender import EmailSender\nimport time\n\n# Configure page\nst.set_page_config(\n    page_title=\"Email Validation & Bulk Sender\",\n    page_icon=\"üìß\",\n    layout=\"wide\",\n    initial_sidebar_state=\"expanded\"\n)\n\n# Initialize session state\nif 'email_credentials' not in st.session_state:\n    st.session_state.email_credentials = {}\nif 'validated_emails' not in st.session_state:\n    st.session_state.validated_emails = pd.DataFrame()\n\ndef main():\n    st.title(\"üìß Email Validation & Bulk Sender Tool\")\n    st.markdown(\"---\")\n    \n    # Sidebar for navigation\n    st.sidebar.title(\"Navigation\")\n    page = st.sidebar.selectbox(\n        \"Choose a feature:\",\n        [\"Single Email Validation\", \"Bulk Email Validation\", \"Email Sender\", \"Scheduled Emails\"]\n    )\n    \n    # Email credentials sidebar\n    st.sidebar.markdown(\"---\")\n    st.sidebar.subheader(\"üìß Email Configuration\")\n    \n    with st.sidebar.expander(\"SMTP Settings\", expanded=False):\n        smtp_server = st.text_input(\"SMTP Server\", value=\"smtp.gmail.com\", key=\"smtp_server\")\n        smtp_port = st.number_input(\"SMTP Port\", value=587, key=\"smtp_port\")\n        email_address = st.text_input(\"Your Email Address\", key=\"email_address\")\n        email_password = st.text_input(\"Email Password/App Password\", type=\"password\", key=\"email_password\")\n        \n        if st.button(\"Save Email Configuration\"):\n            if email_address and email_password:\n                st.session_state.email_credentials = {\n                    'smtp_server': smtp_server,\n                    'smtp_port': smtp_port,\n                    'email': email_address,\n                    'password': email_password\n                }\n                st.success(\"‚úÖ Email configuration saved!\")\n            else:\n                st.error(\"‚ùå Please fill in all email fields\")\n    \n    # Main content based on selected page\n    if page == \"Single Email Validation\":\n        single_email_validation()\n    elif page == \"Bulk Email Validation\":\n        from pages.bulk_validation import show_bulk_validation\n        show_bulk_validation()\n    elif page == \"Email Sender\":\n        email_sender_page()\n    elif page == \"Scheduled Emails\":\n        scheduled_emails_page()\n\ndef single_email_validation():\n    st.header(\"üîç Single Email Validation\")\n    st.markdown(\"Validate individual email addresses for syntax, domain, and deliverability.\")\n    \n    col1, col2 = st.columns([2, 1])\n    \n    with col1:\n        email_to_validate = st.text_input(\"Enter email address to validate:\", placeholder=\"example@domain.com\")\n        \n        if st.button(\"Validate Email\", type=\"primary\"):\n            if email_to_validate:\n                validator = EmailValidator()\n                \n                with st.spinner(\"Validating email...\"):\n                    result = validator.validate_single_email(email_to_validate)\n                \n                # Display simple results\n                if result['is_valid']:\n                    st.success(f\"‚úÖ **{email_to_validate}** valid\")\n                else:\n                    st.error(f\"‚ùå **{email_to_validate}** invalid\")\n            else:\n                st.warning(\"Please enter an email address to validate.\")\n    \n    with col2:\n        st.markdown(\"### Validation Features\")\n        st.info(\"\"\"\n        **What we check:**\n        \n        üî§ **Syntax Validation**\n        - Email format compliance\n        - Special character handling\n        \n        üåê **Domain Verification**\n        - Domain existence check\n        - DNS record validation\n        \n        üì¨ **MX Record Check**\n        - Mail server availability\n        - Priority validation\n        \n        üîå **SMTP Verification**\n        - Mailbox existence\n        - Deliverability test\n        \"\"\")\n\ndef bulk_email_validation():\n    st.header(\"üìã Bulk Email Validation\")\n    st.markdown(\"Upload a CSV file to validate multiple email addresses at once.\")\n    \n    col1, col2 = st.columns([3, 1])\n    \n    with col1:\n        uploaded_file = st.file_uploader(\n            \"Choose a CSV file\",\n            type=['csv'],\n            help=\"CSV should have an 'email' column or emails in the first column\"\n        )\n        \n        if uploaded_file is not None:\n            try:\n                df = pd.read_csv(uploaded_file)\n                st.write(\"### Preview of uploaded data:\")\n                st.dataframe(df.head(), use_container_width=True)\n                \n                # Identify email column\n                email_columns = [col for col in df.columns if 'email' in col.lower()]\n                if email_columns:\n                    email_column = email_columns[0]\n                else:\n                    email_column = df.columns[0]\n                \n                selected_column = st.selectbox(\"Select email column:\", df.columns, index=list(df.columns).index(email_column))\n                \n                if st.button(\"Start Bulk Validation\", type=\"primary\"):\n                    emails_to_validate = df[selected_column].dropna().tolist()\n                    \n                    if emails_to_validate:\n                        validator = EmailValidator()\n                        \n                        # Progress tracking\n                        progress_bar = st.progress(0)\n                        status_text = st.empty()\n                        results_container = st.empty()\n                        \n                        results = []\n                        \n                        for i, email in enumerate(emails_to_validate):\n                            status_text.text(f\"Validating {i+1}/{len(emails_to_validate)}: {email}\")\n                            \n                            result = validator.validate_single_email(email)\n                            result['email'] = email\n                            results.append(result)\n                            \n                            progress_bar.progress((i + 1) / len(emails_to_validate))\n                            \n                            # Show intermediate results\n                            if (i + 1) % 10 == 0 or i == len(emails_to_validate) - 1:\n                                temp_df = pd.DataFrame(results)\n                                valid_count = temp_df['is_valid'].sum()\n                                results_container.metric(\n                                    label=\"Valid Emails Found\",\n                                    value=f\"{valid_count}/{len(temp_df)}\",\n                                    delta=f\"{(valid_count/len(temp_df)*100):.1f}% valid\"\n                                )\n                        \n                        # Final results\n                        results_df = pd.DataFrame(results)\n                        st.session_state.validated_emails = results_df\n                        \n                        status_text.success(f\"‚úÖ Validation complete! Processed {len(results)} emails.\")\n                        \n                        # Summary stats\n                        col1_stats, col2_stats, col3_stats = st.columns(3)\n                        \n                        with col1_stats:\n                            valid_count = results_df['is_valid'].sum()\n                            st.metric(\"Valid Emails\", valid_count, f\"{valid_count/len(results_df)*100:.1f}%\")\n                        \n                        with col2_stats:\n                            invalid_count = len(results_df) - valid_count\n                            st.metric(\"Invalid Emails\", invalid_count, f\"{invalid_count/len(results_df)*100:.1f}%\")\n                        \n                        with col3_stats:\n                            avg_confidence = results_df['confidence'].mean()\n                            st.metric(\"Avg Confidence\", f\"{avg_confidence:.1f}%\")\n                        \n                        # Results table\n                        st.markdown(\"### Validation Results\")\n                        display_df = results_df[['email', 'is_valid', 'confidence', 'syntax_valid', 'domain_valid', 'mx_valid', 'smtp_valid']]\n                        st.dataframe(display_df, use_container_width=True)\n                        \n                        # Export options\n                        csv_data = results_df.to_csv(index=False)\n                        st.download_button(\n                            label=\"üì• Download Full Results (CSV)\",\n                            data=csv_data,\n                            file_name=f\"email_validation_results_{pd.Timestamp.now().strftime('%Y%m%d_%H%M%S')}.csv\",\n                            mime=\"text/csv\"\n                        )\n                        \n                        # Valid emails only export\n                        valid_emails_df = results_df[results_df['is_valid'] == True]\n                        if not valid_emails_df.empty:\n                            valid_emails_series = valid_emails_df['email']\n                            valid_csv = valid_emails_series.to_csv(index=False, header=False)\n                            st.download_button(\n                                label=\"üì• Download Valid Emails Only\",\n                                data=valid_csv,\n                                file_name=f\"valid_emails_{pd.Timestamp.now().strftime('%Y%m%d_%H%M%S')}.csv\",\n                                mime=\"text/csv\"\n                            )\n                    \n            except Exception as e:\n                st.error(f\"Error processing file: {str(e)}\")\n    \n    with col2:\n        st.markdown(\"### CSV Format\")\n        st.info(\"\"\"\n        **Expected format:**\n        \n        ```csv\n        email\n        user1@domain.com\n        user2@domain.com\n        user3@domain.com\n        ```\n        \n        **Or any CSV with email column**\n        \"\"\")\n        \n        # Sample CSV download\n        sample_data = pd.DataFrame({\n            'email': ['user1@example.com', 'user2@test.com', 'invalid-email', 'user3@domain.co.uk']\n        })\n        sample_csv = sample_data.to_csv(index=False)\n        st.download_button(\n            label=\"üì• Download Sample CSV\",\n            data=sample_csv,\n            file_name=\"sample_emails.csv\",\n            mime=\"text/csv\"\n        )\n\ndef email_sender_page():\n    st.header(\"üì§ Email Sender\")\n    st.markdown(\"Compose and send emails individually or in bulk.\")\n    \n    if not st.session_state.email_credentials:\n        st.warning(\"‚ö†Ô∏è Please configure your email credentials in the sidebar first.\")\n        return\n    \n    # Email composition\n    st.subheader(\"‚úçÔ∏è Compose Email\")\n    \n    col1, col2 = st.columns([2, 1])\n    \n    with col1:\n        # Recipients\n        recipient_option = st.radio(\n            \"Select recipients:\",\n            [\"Enter manually\", \"Use validated emails\", \"Upload CSV\"]\n        )\n        \n        recipients = []\n        \n        if recipient_option == \"Enter manually\":\n            recipients_text = st.text_area(\n                \"Recipients (one per line):\",\n                placeholder=\"recipient1@domain.com\\nrecipient2@domain.com\"\n            )\n            if recipients_text:\n                recipients = [email.strip() for email in recipients_text.split('\\n') if email.strip()]\n        \n        elif recipient_option == \"Use validated emails\" and not st.session_state.validated_emails.empty:\n            valid_emails = st.session_state.validated_emails[st.session_state.validated_emails['is_valid'] == True]\n            if not valid_emails.empty:\n                recipients = valid_emails['email'].tolist()\n                st.info(f\"Using {len(recipients)} validated email addresses\")\n            else:\n                st.warning(\"No valid emails found. Please run bulk validation first.\")\n        \n        elif recipient_option == \"Upload CSV\":\n            csv_file = st.file_uploader(\"Upload CSV with email addresses\", type=['csv'], key=\"sender_csv\")\n            if csv_file:\n                try:\n                    df = pd.read_csv(csv_file)\n                    email_col = st.selectbox(\"Select email column:\", df.columns)\n                    recipients = df[email_col].dropna().tolist()\n                    st.info(f\"Loaded {len(recipients)} email addresses\")\n                except Exception as e:\n                    st.error(f\"Error reading CSV: {str(e)}\")\n        \n        # Email content\n        subject = st.text_input(\"Subject:\", placeholder=\"Enter email subject\")\n        \n        message_format = st.radio(\"Message format:\", [\"Plain Text\", \"HTML\"])\n        \n        if message_format == \"Plain Text\":\n            message = st.text_area(\"Message:\", height=200, placeholder=\"Enter your message here...\")\n        else:\n            message = st.text_area(\"HTML Message:\", height=200, placeholder=\"<h1>Your HTML message here...</h1>\")\n        \n        # Send options\n        send_option = st.radio(\"Send option:\", [\"Send now\", \"Schedule for later\"])\n        \n        scheduled_time = None\n        if send_option == \"Schedule for later\":\n            col_date, col_time = st.columns(2)\n            with col_date:\n                schedule_date = st.date_input(\"Date:\")\n            with col_time:\n                schedule_time = st.time_input(\"Time:\")\n            \n            if schedule_date and schedule_time:\n                scheduled_time = pd.Timestamp.combine(schedule_date, schedule_time)\n                st.info(f\"Email will be sent on: {scheduled_time.strftime('%Y-%m-%d %H:%M:%S')}\")\n    \n    with col2:\n        st.markdown(\"### Email Statistics\")\n        if recipients:\n            st.metric(\"Recipients\", len(recipients))\n            st.metric(\"Subject Length\", len(subject) if subject else 0)\n            st.metric(\"Message Length\", len(message) if message else 0)\n        \n        st.markdown(\"### Send Status\")\n        if 'last_send_status' in st.session_state:\n            st.json(st.session_state.last_send_status)\n    \n    # Send button\n    if st.button(\"Send Emails\", type=\"primary\", disabled=not (recipients and subject and message)):\n        if recipients and subject and message:\n            sender = EmailSender(st.session_state.email_credentials)\n            \n            if send_option == \"Send now\":\n                with st.spinner(\"Sending emails...\"):\n                    results = sender.send_bulk_email(recipients, subject, message, is_html=(message_format == \"HTML\"))\n                \n                st.session_state.last_send_status = results\n                \n                # Show results\n                successful = sum(1 for r in results if r['success'])\n                failed = len(results) - successful\n                \n                col1_result, col2_result = st.columns(2)\n                with col1_result:\n                    st.success(f\"‚úÖ Successfully sent: {successful}\")\n                with col2_result:\n                    st.error(f\"‚ùå Failed to send: {failed}\")\n                \n                # Detailed results\n                if failed > 0:\n                    st.markdown(\"### Failed Sends\")\n                    failed_results = [r for r in results if not r['success']]\n                    for result in failed_results:\n                        st.error(f\"‚ùå {result['recipient']}: {result['error']}\")\n            \n            else:  # Schedule for later\n                if scheduled_time:\n                    from utils.scheduler import EmailScheduler\n                    scheduler = EmailScheduler()\n                    \n                    # Ensure scheduled_time is not NaT\n                    scheduled_timestamp = pd.Timestamp(scheduled_time)\n                    if pd.isna(scheduled_timestamp):\n                        st.error(\"Invalid scheduled time\")\n                        return\n                    \n                    job_id = scheduler.schedule_email(\n                        recipients, subject, message, scheduled_timestamp,\n                        st.session_state.email_credentials, is_html=(message_format == \"HTML\")\n                    )\n                    \n                    st.success(f\"‚úÖ Email scheduled successfully! Job ID: {job_id}\")\n                    st.info(f\"Email will be sent on: {scheduled_time.strftime('%Y-%m-%d %H:%M:%S')}\")\n        else:\n            st.error(\"Please fill in all required fields.\")\n\ndef scheduled_emails_page():\n    st.header(\"‚è∞ Scheduled Emails\")\n    st.markdown(\"View and manage your scheduled email jobs.\")\n    \n    from utils.scheduler import EmailScheduler\n    scheduler = EmailScheduler()\n    \n    col1, col2 = st.columns([2, 1])\n    \n    with col1:\n        # Get scheduled jobs\n        jobs = scheduler.get_scheduled_jobs()\n        \n        if jobs:\n            st.subheader(\"üìÖ Scheduled Jobs\")\n            \n            for job in jobs:\n                with st.expander(f\"Job {job['id']} - {job['subject']}\", expanded=False):\n                    col_info, col_action = st.columns([3, 1])\n                    \n                    with col_info:\n                        st.write(f\"**Subject:** {job['subject']}\")\n                        st.write(f\"**Recipients:** {len(job['recipients'])} emails\")\n                        st.write(f\"**Scheduled for:** {job['scheduled_time']}\")\n                        st.write(f\"**Status:** {job['status']}\")\n                        \n                        if job['status'] == 'completed':\n                            st.write(f\"**Sent at:** {job['sent_time']}\")\n                            st.write(f\"**Success rate:** {job['success_count']}/{job['total_count']}\")\n                    \n                    with col_action:\n                        if job['status'] == 'pending':\n                            if st.button(f\"Cancel Job {job['id']}\", key=f\"cancel_{job['id']}\"):\n                                scheduler.cancel_job(job['id'])\n                                st.success(\"Job cancelled!\")\n                                st.rerun()\n        else:\n            st.info(\"üì≠ No scheduled emails found.\")\n    \n    with col2:\n        st.markdown(\"### Quick Actions\")\n        \n        if st.button(\"üîÑ Refresh Jobs\"):\n            st.rerun()\n        \n        if st.button(\"üßπ Clear Completed Jobs\"):\n            scheduler.clear_completed_jobs()\n            st.success(\"Completed jobs cleared!\")\n            st.rerun()\n        \n        st.markdown(\"### Job Status Legend\")\n        st.info(\"\"\"\n        **üìÖ Pending** - Waiting to be sent\n        \n        **üì§ Sending** - Currently sending\n        \n        **‚úÖ Completed** - Successfully sent\n        \n        **‚ùå Failed** - Send failed\n        \n        **‚è∏Ô∏è Cancelled** - Job cancelled\n        \"\"\")\n\nif __name__ == \"__main__\":\n    main()\n","size_bytes":18673},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"dnspython>=2.7.0\",\n    \"email-validator>=2.2.0\",\n    \"pandas>=2.3.2\",\n    \"streamlit>=1.48.1\",\n]\n","size_bytes":244},"replit.md":{"content":"# Overview\n\nThis is a comprehensive Email Validation & Bulk Sender Tool built with Streamlit. The application provides email validation services, bulk email sending capabilities, and scheduled email management. It features a multi-page interface for single/bulk email validation, personalized bulk email campaigns, and scheduled email delivery with real-time monitoring.\n\n# User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n# System Architecture\n\n## Frontend Architecture\n- **Framework**: Streamlit with multi-page application structure\n- **Navigation**: Sidebar-based page selection with expandable configuration sections\n- **State Management**: Session state for email credentials and validation results\n- **UI Components**: Tabs, expandable sections, file uploaders, and real-time data tables\n\n## Backend Architecture\n- **Modular Design**: Utility classes separated by functionality (validation, sending, scheduling)\n- **Email Validation**: Multi-step validation process including syntax, domain, MX records, and SMTP verification\n- **Email Sending**: SMTP-based email delivery with support for HTML content and attachments\n- **Scheduling System**: File-based job persistence with background thread execution\n\n## Core Components\n\n### Email Validation System\n- **Syntax Validation**: Uses `email-validator` library for RFC compliance\n- **Domain Verification**: DNS resolution and domain existence checks\n- **MX Record Validation**: Mail exchanger record verification\n- **SMTP Verification**: Optional connection testing to target mail servers\n- **Caching**: MX record caching for performance optimization\n\n### Email Delivery System\n- **SMTP Integration**: Configurable SMTP servers with SSL/TLS support\n- **Template Support**: HTML and plain text email formatting\n- **Attachment Handling**: File attachment support via MIME encoding\n- **Batch Processing**: Bulk sending with rate limiting and error handling\n\n### Scheduling Engine\n- **Job Persistence**: JSON file-based job storage\n- **Background Processing**: Threaded scheduler for non-blocking execution\n- **Status Tracking**: Real-time job status monitoring (pending, sending, completed, failed)\n- **Management Interface**: Job viewing, cancellation, and cleanup capabilities\n\n## Data Flow\n1. **Configuration**: Users set SMTP credentials via sidebar interface\n2. **Validation**: Email addresses processed through multi-stage validation pipeline\n3. **Composition**: Email content created with recipient management and template support\n4. **Delivery**: Immediate sending or scheduled execution via background processor\n5. **Monitoring**: Real-time status updates and job management through dedicated interface\n\n## Security Considerations\n- **Credential Storage**: Session-based credential management (no persistent storage)\n- **SSL/TLS**: Secure email transmission protocols\n- **Input Validation**: Email address sanitization and validation\n- **Error Handling**: Comprehensive error catching and user feedback\n\n# External Dependencies\n\n## Python Libraries\n- **streamlit**: Web application framework and UI components\n- **pandas**: Data manipulation and CSV processing\n- **email-validator**: RFC-compliant email syntax validation\n- **dnspython**: DNS resolution for domain and MX record verification\n- **smtplib**: Built-in SMTP client for email delivery\n\n## Email Services\n- **SMTP Servers**: Configurable support for Gmail, Outlook, and custom SMTP providers\n- **Authentication**: Email/password or app-specific password authentication\n- **SSL/TLS**: Secure connection protocols for email transmission\n\n## File System\n- **CSV Processing**: File upload and parsing for bulk operations\n- **Job Persistence**: JSON file storage for scheduled email jobs\n- **Attachment Support**: File system access for email attachments\n\n## Network Services\n- **DNS Resolution**: Domain validation and MX record lookup\n- **SMTP Connectivity**: Real-time email server connection testing\n- **Background Processing**: Threaded execution for scheduled operations","size_bytes":4021},"pages/bulk_sender.py":{"content":"import streamlit as st\nimport pandas as pd\nfrom utils.email_sender import EmailSender, EmailTemplate\nfrom datetime import datetime, timedelta\nimport time\n\ndef show_bulk_sender():\n    st.header(\"üì§ Bulk Email Sender\")\n    st.markdown(\"Send personalized emails to multiple recipients with scheduling options.\")\n    \n    # Check email configuration\n    if 'email_credentials' not in st.session_state or not st.session_state.email_credentials:\n        st.warning(\"‚ö†Ô∏è Please configure your email credentials in the main page sidebar first.\")\n        return\n    \n    # Test email connection\n    test_connection()\n    \n    # Email composition interface\n    compose_email_interface()\n\ndef test_connection():\n    \"\"\"Test email connection\"\"\"\n    st.subheader(\"üîå Email Connection Status\")\n    \n    if st.button(\"Test Email Connection\"):\n        sender = EmailSender(st.session_state.email_credentials)\n        result = sender.test_connection()\n        \n        if result['success']:\n            st.success(\"‚úÖ Email connection successful!\")\n        else:\n            st.error(f\"‚ùå Connection failed: {result['error']}\")\n\ndef compose_email_interface():\n    \"\"\"Main email composition interface\"\"\"\n    \n    # Recipient management\n    st.subheader(\"üë• Manage Recipients\")\n    \n    recipient_tabs = st.tabs([\"Manual Entry\", \"Upload CSV\", \"From Validation Results\"])\n    \n    recipients = []\n    \n    with recipient_tabs[0]:\n        recipients_text = st.text_area(\n            \"Enter email addresses (one per line):\",\n            height=150,\n            placeholder=\"recipient1@example.com\\nrecipient2@example.com\\nrecipient3@example.com\"\n        )\n        \n        if recipients_text:\n            recipients = [email.strip() for email in recipients_text.split('\\n') if email.strip()]\n            st.info(f\"üìß {len(recipients)} recipients entered\")\n    \n    with recipient_tabs[1]:\n        uploaded_file = st.file_uploader(\"Upload CSV with recipients\", type=['csv'])\n        \n        if uploaded_file:\n            try:\n                df = pd.read_csv(uploaded_file)\n                st.dataframe(df.head(), use_container_width=True)\n                \n                email_column = st.selectbox(\"Select email column:\", df.columns)\n                \n                if email_column:\n                    recipients = df[email_column].dropna().tolist()\n                    st.info(f\"üìß {len(recipients)} recipients loaded from CSV\")\n            \n            except Exception as e:\n                st.error(f\"Error reading CSV: {str(e)}\")\n    \n    with recipient_tabs[2]:\n        if 'validated_emails' in st.session_state and not st.session_state.validated_emails.empty:\n            valid_emails = st.session_state.validated_emails[\n                st.session_state.validated_emails['is_valid'] == True\n            ]\n            \n            if not valid_emails.empty:\n                use_validated = st.checkbox(\"Use validated email addresses\")\n                \n                if use_validated:\n                    recipients = valid_emails['email'].tolist()\n                    st.success(f\"‚úÖ Using {len(recipients)} validated email addresses\")\n            else:\n                st.info(\"No validated emails available. Run email validation first.\")\n        else:\n            st.info(\"No validated emails available. Run email validation first.\")\n    \n    if not recipients:\n        st.warning(\"üì≠ No recipients selected. Please add some email addresses.\")\n        return\n    \n    # Email content composition\n    st.subheader(\"‚úçÔ∏è Compose Email\")\n    \n    # Template selection\n    template_option = st.selectbox(\n        \"Choose email template:\",\n        [\"Custom Message\", \"Welcome Email\", \"Newsletter\", \"Notification\"]\n    )\n    \n    # Subject line\n    subject = st.text_input(\"Subject Line:\", placeholder=\"Enter your email subject\")\n    \n    # Message composition based on template\n    if template_option == \"Custom Message\":\n        compose_custom_message()\n    elif template_option == \"Welcome Email\":\n        compose_welcome_email(subject)\n    elif template_option == \"Newsletter\":\n        compose_newsletter(subject)\n    elif template_option == \"Notification\":\n        compose_notification(subject)\n    \n    # Get composed message from session state\n    message = st.session_state.get('composed_message', '')\n    is_html = st.session_state.get('message_is_html', False)\n    \n    # Preview section\n    if message:\n        with st.expander(\"üìã Email Preview\", expanded=False):\n            if is_html:\n                st.markdown(\"**HTML Preview:**\")\n                st.markdown(message, unsafe_allow_html=True)\n            else:\n                st.markdown(\"**Text Preview:**\")\n                st.text(message)\n    \n    # Sending options\n    st.subheader(\"üìÖ Sending Options\")\n    \n    col1, col2 = st.columns(2)\n    \n    with col1:\n        send_option = st.radio(\n            \"When to send:\",\n            [\"Send Immediately\", \"Schedule for Later\"]\n        )\n    \n    with col2:\n        schedule_datetime = None\n        if send_option == \"Schedule for Later\":\n            schedule_date = st.date_input(\n                \"Schedule Date:\",\n                value=datetime.now() + timedelta(hours=1),\n                min_value=datetime.now()\n            )\n            schedule_time = st.time_input(\n                \"Schedule Time:\",\n                value=(datetime.now() + timedelta(hours=1)).time()\n            )\n            schedule_datetime = datetime.combine(schedule_date, schedule_time)\n    \n    # Advanced options\n    with st.expander(\"‚öôÔ∏è Advanced Options\", expanded=False):\n        delay_between_emails = st.slider(\n            \"Delay between emails (seconds):\",\n            min_value=0.1,\n            max_value=10.0,\n            value=1.0,\n            step=0.1,\n            help=\"Add delay to avoid being flagged as spam\"\n        )\n        \n        test_mode = st.checkbox(\n            \"Test mode (send only to first 3 recipients)\",\n            help=\"Use this to test your email before sending to all recipients\"\n        )\n    \n    # Send button\n    if st.button(\"üöÄ Send Emails\", type=\"primary\", disabled=not (recipients and subject and message)):\n        if send_option == \"Schedule for Later\":\n            scheduled_dt = schedule_datetime\n        else:\n            scheduled_dt = None\n        \n        send_emails(\n            recipients, subject, message, is_html,\n            send_option, scheduled_dt,\n            delay_between_emails, test_mode\n        )\n\ndef compose_custom_message():\n    \"\"\"Custom message composition\"\"\"\n    message_format = st.radio(\"Message format:\", [\"Plain Text\", \"HTML\"])\n    \n    if message_format == \"Plain Text\":\n        message = st.text_area(\n            \"Email Message:\",\n            height=200,\n            placeholder=\"Enter your message here...\"\n        )\n        st.session_state.composed_message = message\n        st.session_state.message_is_html = False\n    else:\n        message = st.text_area(\n            \"HTML Message:\",\n            height=200,\n            placeholder=\"<h1>Your HTML message here...</h1>\\n<p>You can use HTML tags for formatting.</p>\"\n        )\n        st.session_state.composed_message = message\n        st.session_state.message_is_html = True\n\ndef compose_welcome_email(subject):\n    \"\"\"Welcome email template\"\"\"\n    col1, col2 = st.columns(2)\n    \n    with col1:\n        recipient_name = st.text_input(\"Recipient Name:\", placeholder=\"New User\")\n    \n    with col2:\n        company_name = st.text_input(\"Company Name:\", placeholder=\"Your Company\")\n    \n    if recipient_name and company_name:\n        message = EmailTemplate.create_welcome_template(recipient_name, company_name)\n        st.session_state.composed_message = message\n        st.session_state.message_is_html = True\n        \n        if not subject:\n            st.session_state.default_subject = f\"Welcome to {company_name}, {recipient_name}!\"\n\ndef compose_newsletter(subject):\n    \"\"\"Newsletter template\"\"\"\n    newsletter_title = st.text_input(\"Newsletter Title:\", placeholder=\"Monthly Newsletter\")\n    newsletter_content = st.text_area(\n        \"Newsletter Content (HTML):\",\n        height=150,\n        placeholder=\"<p>Your newsletter content here...</p>\"\n    )\n    unsubscribe_link = st.text_input(\n        \"Unsubscribe Link:\",\n        placeholder=\"https://yoursite.com/unsubscribe\"\n    )\n    \n    if newsletter_title and newsletter_content:\n        message = EmailTemplate.create_newsletter_template(\n            newsletter_title, newsletter_content, unsubscribe_link or \"#\"\n        )\n        st.session_state.composed_message = message\n        st.session_state.message_is_html = True\n\ndef compose_notification(subject):\n    \"\"\"Notification template\"\"\"\n    notification_message = st.text_area(\n        \"Notification Message:\",\n        height=100,\n        placeholder=\"Important update or notification...\"\n    )\n    action_url = st.text_input(\n        \"Action URL (optional):\",\n        placeholder=\"https://yoursite.com/action\"\n    )\n    \n    if notification_message:\n        message = EmailTemplate.create_notification_template(\n            subject or \"Important Notification\",\n            notification_message,\n            action_url\n        )\n        st.session_state.composed_message = message\n        st.session_state.message_is_html = True\n\ndef send_emails(recipients, subject, message, is_html, send_option, \n                schedule_datetime, delay, test_mode):\n    \"\"\"Send or schedule emails\"\"\"\n    \n    # Apply test mode\n    if test_mode:\n        recipients = recipients[:3]\n        st.info(f\"üß™ Test mode: Sending to first {len(recipients)} recipients only\")\n    \n    if send_option == \"Send Immediately\":\n        send_immediately(recipients, subject, message, is_html, delay)\n    else:\n        schedule_emails(recipients, subject, message, is_html, schedule_datetime)\n\ndef send_immediately(recipients, subject, message, is_html, delay):\n    \"\"\"Send emails immediately\"\"\"\n    sender = EmailSender(st.session_state.email_credentials)\n    \n    # Progress tracking\n    progress_bar = st.progress(0)\n    status_text = st.empty()\n    \n    # Results tracking\n    successful_sends = 0\n    failed_sends = []\n    \n    # Send emails\n    for i, recipient in enumerate(recipients):\n        status_text.text(f\"Sending to {recipient} ({i+1}/{len(recipients)})\")\n        \n        result = sender.send_single_email(recipient, subject, message, is_html)\n        \n        if result['success']:\n            successful_sends += 1\n        else:\n            failed_sends.append(result)\n        \n        progress_bar.progress((i + 1) / len(recipients))\n        \n        # Add delay between sends\n        if i < len(recipients) - 1:\n            time.sleep(delay)\n    \n    # Show results\n    status_text.empty()\n    \n    col1, col2 = st.columns(2)\n    with col1:\n        st.success(f\"‚úÖ Successfully sent: {successful_sends}/{len(recipients)}\")\n    with col2:\n        if failed_sends:\n            st.error(f\"‚ùå Failed sends: {len(failed_sends)}\")\n    \n    # Show failed sends details\n    if failed_sends:\n        with st.expander(\"‚ùå Failed Sends Details\", expanded=False):\n            for failed in failed_sends:\n                st.error(f\"**{failed['recipient']}:** {failed['error']}\")\n\ndef schedule_emails(recipients, subject, message, is_html, schedule_datetime):\n    \"\"\"Schedule emails for later sending\"\"\"\n    from utils.scheduler import get_scheduler\n    \n    scheduler = get_scheduler()\n    \n    if schedule_datetime:\n        # Ensure scheduled_time is not NaT\n        scheduled_timestamp = pd.Timestamp(schedule_datetime)\n        if pd.isna(scheduled_timestamp):\n            st.error(\"Invalid scheduled time\")\n            return\n        \n        job_id = scheduler.schedule_email(\n            recipients, subject, message,\n            scheduled_timestamp,\n            st.session_state.email_credentials,\n            is_html\n        )\n    else:\n        st.error(\"Schedule date/time not provided\")\n        return\n    \n    st.success(f\"üìÖ Email scheduled successfully!\")\n    st.info(f\"**Job ID:** {job_id}\")\n    st.info(f\"**Scheduled for:** {schedule_datetime.strftime('%Y-%m-%d %H:%M:%S')}\")\n    st.info(f\"**Recipients:** {len(recipients)} emails\")\n\nif __name__ == \"__main__\":\n    show_bulk_sender()\n","size_bytes":12253},"pages/bulk_validation.py":{"content":"import streamlit as st\nimport pandas as pd\nfrom utils.email_validator import EmailValidator\nimport time\n\ndef show_bulk_validation():\n    st.header(\"üìã Bulk Email Validation\")\n    st.markdown(\"Validate multiple email addresses at once using CSV upload or direct paste.\")\n    \n    # Input method selection\n    input_method = st.radio(\n        \"Choose input method:\",\n        [\"üìÑ Upload CSV File\", \"üìù Paste Email Addresses\"],\n        horizontal=True\n    )\n    \n    emails_to_validate = []\n    \n    if input_method == \"üìÑ Upload CSV File\":\n        # File upload section\n        uploaded_file = st.file_uploader(\n            \"Choose a CSV file\",\n            type=['csv'],\n            help=\"Your CSV file should contain a column with email addresses\"\n        )\n        \n        if uploaded_file is not None:\n            try:\n                # Read CSV file\n                df = pd.read_csv(uploaded_file)\n                \n                st.subheader(\"üìä Data Preview\")\n                st.dataframe(df.head(10), use_container_width=True)\n                \n                # Column selection\n                st.subheader(\"üéØ Select Email Column\")\n                email_column = st.selectbox(\n                    \"Which column contains the email addresses?\",\n                    df.columns,\n                    index=0 if 'email' not in [col.lower() for col in df.columns] \n                    else [col.lower() for col in df.columns].index('email')\n                )\n                \n                # Preview selected emails\n                if email_column:\n                    emails_to_validate = df[email_column].dropna().unique().tolist()\n                    st.info(f\"Found {len(emails_to_validate)} unique email addresses to validate\")\n                    \n                    with st.expander(\"Preview email addresses\", expanded=False):\n                        st.write(emails_to_validate[:20])  # Show first 20\n                        if len(emails_to_validate) > 20:\n                            st.write(f\"... and {len(emails_to_validate) - 20} more\")\n            \n            except Exception as e:\n                st.error(f\"Error reading CSV file: {str(e)}\")\n                st.info(\"Make sure your CSV file is properly formatted and contains email addresses\")\n    \n    elif input_method == \"üìù Paste Email Addresses\":\n        # Direct paste section\n        st.subheader(\"üìù Paste Email Addresses\")\n        \n        email_text = st.text_area(\n            \"Enter email addresses (one per line):\",\n            height=200,\n            placeholder=\"user1@example.com\\nuser2@domain.com\\nuser3@test.org\\n...\",\n            help=\"Enter one email address per line\"\n        )\n        \n        if email_text:\n            # Parse pasted emails\n            raw_emails = [email.strip() for email in email_text.split('\\n') if email.strip()]\n            emails_to_validate = list(set(raw_emails))  # Remove duplicates\n            \n            st.info(f\"Found {len(emails_to_validate)} unique email addresses to validate\")\n            \n            with st.expander(\"Preview email addresses\", expanded=False):\n                st.write(emails_to_validate[:20])  # Show first 20\n                if len(emails_to_validate) > 20:\n                    st.write(f\"... and {len(emails_to_validate) - 20} more\")\n    \n    # Validation settings (common for both methods)\n    if emails_to_validate:\n        st.subheader(\"‚öôÔ∏è Validation Settings\")\n        col1, col2 = st.columns(2)\n        \n        with col1:\n            skip_smtp = st.checkbox(\n                \"Skip SMTP verification (faster)\",\n                value=False,\n                help=\"SMTP verification is more accurate but slower\"\n            )\n        \n        with col2:\n            batch_size = st.slider(\n                \"Batch size\",\n                min_value=10,\n                max_value=100,\n                value=50,\n                help=\"Number of emails to validate at once\"\n            )\n        \n        # Start validation\n        if st.button(\"üöÄ Start Validation\", type=\"primary\"):\n            if emails_to_validate:\n                validate_emails(emails_to_validate, skip_smtp, batch_size)\n            else:\n                st.error(\"No valid email addresses found\")\n\ndef validate_emails(emails, skip_smtp, batch_size):\n    \"\"\"Validate a list of emails with progress tracking\"\"\"\n    \n    validator = EmailValidator()\n    \n    # Initialize progress tracking\n    progress_bar = st.progress(0)\n    status_text = st.empty()\n    \n    # Results containers\n    results_container = st.container()\n    \n    all_results = []\n    total_emails = len(emails)\n    \n    # Process in batches\n    for i in range(0, total_emails, batch_size):\n        batch = emails[i:i + batch_size]\n        batch_results = []\n        \n        for j, email in enumerate(batch):\n            current_index = i + j + 1\n            status_text.text(f\"Validating email {current_index}/{total_emails}: {email}\")\n            \n            # Validate email\n            result = validator.validate_single_email(email)\n            \n            # Skip SMTP if requested\n            if skip_smtp:\n                result['smtp_valid'] = None\n                # Recalculate confidence without SMTP\n                confidence = 0\n                if result['syntax_valid']: confidence += 35\n                if result['domain_valid']: confidence += 35\n                if result['mx_valid']: confidence += 30\n                result['confidence'] = confidence\n                result['is_valid'] = confidence >= 70\n            \n            batch_results.append(result)\n            all_results.append(result)\n            \n            # Update progress\n            progress = current_index / total_emails\n            progress_bar.progress(progress)\n            \n            # Small delay to prevent overwhelming servers\n            time.sleep(0.1)\n        \n        # Show intermediate results\n        if len(all_results) % 50 == 0 or len(all_results) == total_emails:\n            show_validation_results(all_results, results_container)\n    \n    # Final results\n    status_text.success(f\"‚úÖ Validation completed! Processed {len(all_results)} emails.\")\n    show_validation_results(all_results, results_container, final=True)\n\ndef show_validation_results(results, container, final=False):\n    \"\"\"Display validation results\"\"\"\n    \n    with container:\n        if final:\n            st.subheader(\"üìä Final Validation Results\")\n        \n        # Convert to DataFrame\n        results_df = pd.DataFrame(results)\n        \n        # Summary statistics\n        col1, col2, col3, col4 = st.columns(4)\n        \n        valid_count = results_df['is_valid'].sum()\n        invalid_count = len(results_df) - valid_count\n        avg_confidence = results_df['confidence'].mean()\n        syntax_valid = results_df['syntax_valid'].sum()\n        \n        col1.metric(\"‚úÖ Valid Emails\", valid_count, f\"{valid_count/len(results_df)*100:.1f}%\")\n        col2.metric(\"‚ùå Invalid Emails\", invalid_count, f\"{invalid_count/len(results_df)*100:.1f}%\")\n        col3.metric(\"üìä Avg Confidence\", f\"{avg_confidence:.1f}%\")\n        col4.metric(\"‚úèÔ∏è Syntax Valid\", syntax_valid, f\"{syntax_valid/len(results_df)*100:.1f}%\")\n        \n        # Filter options\n        if final:\n            st.subheader(\"üîç Filter Results\")\n            filter_option = st.selectbox(\n                \"Show emails:\",\n                [\"All emails\", \"Valid emails only\", \"Invalid emails only\", \"High confidence (>80%)\", \"Low confidence (<50%)\"]\n            )\n            \n            if filter_option == \"Valid emails only\":\n                display_df = results_df[results_df['is_valid'] == True]\n            elif filter_option == \"Invalid emails only\":\n                display_df = results_df[results_df['is_valid'] == False]\n            elif filter_option == \"High confidence (>80%)\":\n                display_df = results_df[results_df['confidence'] > 80]\n            elif filter_option == \"Low confidence (<50%)\":\n                display_df = results_df[results_df['confidence'] < 50]\n            else:\n                display_df = results_df\n            \n            # Sort by confidence\n            if 'confidence' in display_df.columns:\n                display_df = display_df.sort_values('confidence', ascending=False)\n        else:\n            display_df = results_df\n        \n        # Display results table\n        st.dataframe(\n            display_df[['email', 'is_valid', 'confidence', 'syntax_valid', 'domain_valid', 'mx_valid', 'smtp_valid']],\n            use_container_width=True\n        )\n        \n        if final:\n            # Export options\n            st.subheader(\"üì• Export Results\")\n            \n            col1, col2 = st.columns(2)\n            \n            with col1:\n                # Full results export\n                csv_data = results_df.to_csv(index=False)\n                st.download_button(\n                    label=\"üìÑ Download All Results (CSV)\",\n                    data=csv_data,\n                    file_name=f\"email_validation_results_{pd.Timestamp.now().strftime('%Y%m%d_%H%M%S')}.csv\",\n                    mime=\"text/csv\"\n                )\n            \n            with col2:\n                # Valid emails only\n                valid_emails_df = results_df[results_df['is_valid'] == True]\n                if not valid_emails_df.empty:\n                    valid_emails_series = valid_emails_df['email']\n                    valid_csv = valid_emails_series.to_csv(index=False, header=True)\n                    st.download_button(\n                        label=\"‚úÖ Download Valid Emails Only\",\n                        data=valid_csv,\n                        file_name=f\"valid_emails_{pd.Timestamp.now().strftime('%Y%m%d_%H%M%S')}.csv\",\n                        mime=\"text/csv\"\n                    )\n                else:\n                    st.info(\"No valid emails to export\")\n\nif __name__ == \"__main__\":\n    show_bulk_validation()\n","size_bytes":9952},"pages/scheduled_emails.py":{"content":"import streamlit as st\nimport pandas as pd\nfrom utils.scheduler import get_scheduler\nfrom datetime import datetime\nimport json\n\ndef show_scheduled_emails():\n    st.header(\"‚è∞ Scheduled Email Management\")\n    st.markdown(\"View, manage, and monitor your scheduled email campaigns.\")\n    \n    scheduler = get_scheduler()\n    \n    # Refresh button\n    col1, col2, col3 = st.columns([1, 1, 2])\n    \n    with col1:\n        if st.button(\"üîÑ Refresh\"):\n            st.rerun()\n    \n    with col2:\n        if st.button(\"üßπ Clear Completed\"):\n            scheduler.clear_completed_jobs()\n            st.success(\"Completed jobs cleared!\")\n            st.rerun()\n    \n    # Get all scheduled jobs\n    jobs = scheduler.get_scheduled_jobs()\n    \n    if not jobs:\n        st.info(\"üì≠ No scheduled emails found.\")\n        \n        # Quick scheduling section\n        st.subheader(\"‚ö° Quick Schedule\")\n        st.markdown(\"Go to the **Email Sender** page to create new scheduled emails.\")\n        \n        return\n    \n    # Statistics overview\n    show_job_statistics(jobs)\n    \n    # Jobs management interface\n    st.subheader(\"üìã Scheduled Jobs\")\n    \n    # Filter options\n    status_filter = st.selectbox(\n        \"Filter by status:\",\n        [\"All\", \"Pending\", \"Sending\", \"Completed\", \"Failed\", \"Cancelled\"]\n    )\n    \n    filtered_jobs = jobs\n    if status_filter != \"All\":\n        filtered_jobs = [job for job in jobs if job['status'].lower() == status_filter.lower()]\n    \n    if not filtered_jobs:\n        st.info(f\"No jobs with status '{status_filter}' found.\")\n        return\n    \n    # Display jobs\n    for job in filtered_jobs:\n        display_job_card(job, scheduler)\n\ndef show_job_statistics(jobs):\n    \"\"\"Display job statistics overview\"\"\"\n    st.subheader(\"üìä Overview\")\n    \n    # Calculate statistics\n    total_jobs = len(jobs)\n    pending_jobs = sum(1 for job in jobs if job['status'] == 'pending')\n    completed_jobs = sum(1 for job in jobs if job['status'] == 'completed')\n    failed_jobs = sum(1 for job in jobs if job['status'] == 'failed')\n    cancelled_jobs = sum(1 for job in jobs if job['status'] == 'cancelled')\n    \n    # Display metrics\n    col1, col2, col3, col4, col5 = st.columns(5)\n    \n    with col1:\n        st.metric(\"üìß Total Jobs\", total_jobs)\n    \n    with col2:\n        st.metric(\"‚è≥ Pending\", pending_jobs)\n    \n    with col3:\n        st.metric(\"‚úÖ Completed\", completed_jobs)\n    \n    with col4:\n        st.metric(\"‚ùå Failed\", failed_jobs)\n    \n    with col5:\n        st.metric(\"‚è∏Ô∏è Cancelled\", cancelled_jobs)\n    \n    # Success rate\n    if completed_jobs > 0:\n        total_emails_sent = sum(job.get('success_count', 0) for job in jobs if job['status'] == 'completed')\n        total_emails_attempted = sum(job.get('total_count', 0) for job in jobs if job['status'] == 'completed')\n        \n        if total_emails_attempted > 0:\n            success_rate = (total_emails_sent / total_emails_attempted) * 100\n            st.metric(\"üìà Overall Success Rate\", f\"{success_rate:.1f}%\")\n\ndef display_job_card(job, scheduler):\n    \"\"\"Display individual job card\"\"\"\n    \n    # Status emoji mapping\n    status_emojis = {\n        'pending': '‚è≥',\n        'sending': 'üì§',\n        'completed': '‚úÖ',\n        'failed': '‚ùå',\n        'cancelled': '‚è∏Ô∏è'\n    }\n    \n    status_emoji = status_emojis.get(job['status'], '‚ùì')\n    \n    # Job card container\n    with st.container():\n        # Header\n        col1, col2, col3 = st.columns([3, 1, 1])\n        \n        with col1:\n            st.markdown(f\"### {status_emoji} {job['subject']}\")\n            st.caption(f\"Job ID: {job['id']}\")\n        \n        with col2:\n            st.markdown(f\"**Status:** {job['status'].title()}\")\n        \n        with col3:\n            if job['status'] == 'pending':\n                if st.button(f\"‚ùå Cancel\", key=f\"cancel_{job['id']}\"):\n                    if scheduler.cancel_job(job['id']):\n                        st.success(\"Job cancelled!\")\n                        st.rerun()\n                    else:\n                        st.error(\"Failed to cancel job\")\n        \n        # Job details\n        col1, col2, col3 = st.columns(3)\n        \n        with col1:\n            st.write(f\"**Recipients:** {job['total_count']}\")\n            st.write(f\"**Created:** {format_datetime(job['created_time'])}\")\n        \n        with col2:\n            st.write(f\"**Scheduled for:** {format_datetime(job['scheduled_time'])}\")\n            if job.get('sent_time'):\n                st.write(f\"**Sent at:** {format_datetime(job['sent_time'])}\")\n        \n        with col3:\n            if job['status'] == 'completed':\n                st.write(f\"**Success rate:** {job.get('success_count', 0)}/{job['total_count']}\")\n                success_rate = (job.get('success_count', 0) / job['total_count']) * 100\n                st.progress(success_rate / 100)\n            elif job['status'] == 'failed':\n                st.write(f\"**Error:** {job.get('error', 'Unknown error')}\")\n        \n        # Expandable details\n        with st.expander(f\"üìã Details for Job {job['id']}\", expanded=False):\n            \n            # Email content preview\n            st.markdown(\"**Email Preview:**\")\n            if job.get('is_html', False):\n                # For HTML, show raw HTML (could be improved with HTML renderer)\n                with st.container():\n                    st.code(job['message'][:500] + \"...\" if len(job['message']) > 500 else job['message'], language='html')\n            else:\n                st.text(job['message'][:300] + \"...\" if len(job['message']) > 300 else job['message'])\n            \n            # Recipients list\n            st.markdown(\"**Recipients:**\")\n            recipients_text = \"\\n\".join(job['recipients'][:10])\n            if len(job['recipients']) > 10:\n                recipients_text += f\"\\n... and {len(job['recipients']) - 10} more\"\n            st.text(recipients_text)\n            \n            # Results details (if completed)\n            if job['status'] == 'completed' and job.get('results'):\n                st.markdown(\"**Sending Results:**\")\n                \n                # Convert results to DataFrame for better display\n                results_df = pd.DataFrame(job['results'])\n                \n                # Summary\n                success_count = results_df['success'].sum()\n                total_count = len(results_df)\n                \n                st.write(f\"‚úÖ Successful: {success_count}/{total_count}\")\n                \n                # Show failed sends\n                failed_results = results_df[results_df['success'] == False]\n                if not failed_results.empty:\n                    st.write(\"‚ùå **Failed sends:**\")\n                    for _, failed in failed_results.iterrows():\n                        st.write(f\"  - {failed['recipient']}: {failed.get('error', 'Unknown error')}\")\n            \n            # Raw job data (for debugging)\n            if st.checkbox(f\"Show raw data for job {job['id']}\", key=f\"raw_{job['id']}\"):\n                st.json(job)\n        \n        st.markdown(\"---\")\n\ndef format_datetime(datetime_str):\n    \"\"\"Format datetime string for display\"\"\"\n    if not datetime_str:\n        return \"Not set\"\n    \n    try:\n        dt = pd.Timestamp(datetime_str)\n        # Check if timestamp is valid\n        if pd.isna(dt) or str(dt) == 'NaT':\n            return \"Not set\"\n        return dt.strftime(\"%Y-%m-%d %H:%M:%S\")\n    except Exception:\n        return str(datetime_str) if datetime_str else \"Not set\"\n\ndef show_job_logs():\n    \"\"\"Show detailed logs for job execution\"\"\"\n    st.subheader(\"üìú Job Execution Logs\")\n    \n    # This could be expanded to show more detailed logs\n    # For now, we'll just show basic information\n    \n    if st.button(\"üì• Download Job History\"):\n        scheduler = get_scheduler()\n        jobs = scheduler.get_scheduled_jobs()\n        \n        # Convert to DataFrame\n        df = pd.DataFrame(jobs)\n        \n        if not df.empty:\n            # Select relevant columns\n            export_columns = ['id', 'subject', 'total_count', 'status', \n                            'scheduled_time', 'sent_time', 'success_count']\n            \n            export_df = df[export_columns]\n            csv_data = export_df.to_csv(index=False)\n            \n            st.download_button(\n                label=\"üì• Download CSV\",\n                data=csv_data,\n                file_name=f\"scheduled_jobs_history_{pd.Timestamp.now().strftime('%Y%m%d_%H%M%S')}.csv\",\n                mime=\"text/csv\"\n            )\n        else:\n            st.info(\"No job history to export\")\n\nif __name__ == \"__main__\":\n    show_scheduled_emails()\n","size_bytes":8654},"utils/email_sender.py":{"content":"import smtplib\nimport ssl\nfrom email.mime.text import MIMEText\nfrom email.mime.multipart import MIMEMultipart\nfrom email.mime.base import MIMEBase\nfrom email import encoders\nfrom typing import List, Dict, Optional\nimport time\nfrom datetime import datetime\n\nclass EmailSender:\n    def __init__(self, credentials: Dict):\n        self.smtp_server = credentials['smtp_server']\n        self.smtp_port = credentials['smtp_port']\n        self.email = credentials['email']\n        self.password = credentials['password']\n    \n    def send_single_email(self, recipient: str, subject: str, message: str, \n                         is_html: bool = False, attachments: Optional[List] = None) -> Dict:\n        \"\"\"\n        Send a single email\n        \"\"\"\n        result = {\n            'recipient': recipient,\n            'success': False,\n            'error': None,\n            'sent_time': None\n        }\n        \n        try:\n            # Create message\n            msg = MIMEMultipart()\n            msg['From'] = self.email\n            msg['To'] = recipient\n            msg['Subject'] = subject\n            \n            # Add body to email\n            if is_html:\n                msg.attach(MIMEText(message, 'html'))\n            else:\n                msg.attach(MIMEText(message, 'plain'))\n            \n            # Add attachments if any\n            if attachments:\n                for attachment in attachments:\n                    self._add_attachment(msg, attachment)\n            \n            # Create SMTP session\n            context = ssl.create_default_context()\n            \n            with smtplib.SMTP(self.smtp_server, self.smtp_port) as server:\n                server.starttls(context=context)\n                server.login(self.email, self.password)\n                \n                # Send email\n                server.send_message(msg)\n                \n                result['success'] = True\n                result['sent_time'] = datetime.now().isoformat()\n                \n        except smtplib.SMTPAuthenticationError:\n            result['error'] = \"Authentication failed. Check email credentials.\"\n        except smtplib.SMTPRecipientsRefused:\n            result['error'] = \"Recipient email address was refused by server.\"\n        except smtplib.SMTPSenderRefused:\n            result['error'] = \"Sender email address was refused by server.\"\n        except smtplib.SMTPDataError:\n            result['error'] = \"SMTP data error occurred.\"\n        except smtplib.SMTPConnectError:\n            result['error'] = \"Failed to connect to SMTP server.\"\n        except smtplib.SMTPServerDisconnected:\n            result['error'] = \"SMTP server disconnected unexpectedly.\"\n        except Exception as e:\n            result['error'] = f\"Unexpected error: {str(e)}\"\n        \n        return result\n    \n    def send_bulk_email(self, recipients: List[str], subject: str, message: str, \n                       is_html: bool = False, delay: float = 0.5) -> List[Dict]:\n        \"\"\"\n        Send email to multiple recipients with optional delay between sends\n        \"\"\"\n        results = []\n        \n        for i, recipient in enumerate(recipients):\n            result = self.send_single_email(recipient, subject, message, is_html)\n            results.append(result)\n            \n            # Add delay between sends to avoid being flagged as spam\n            if i < len(recipients) - 1 and delay > 0:\n                time.sleep(delay)\n        \n        return results\n    \n    def _add_attachment(self, msg: MIMEMultipart, file_path: str):\n        \"\"\"\n        Add attachment to email message\n        \"\"\"\n        try:\n            with open(file_path, \"rb\") as attachment:\n                part = MIMEBase('application', 'octet-stream')\n                part.set_payload(attachment.read())\n            \n            encoders.encode_base64(part)\n            \n            part.add_header(\n                'Content-Disposition',\n                f'attachment; filename= {file_path.split(\"/\")[-1]}',\n            )\n            \n            msg.attach(part)\n        except Exception as e:\n            print(f\"Failed to attach file {file_path}: {str(e)}\")\n    \n    def test_connection(self) -> Dict:\n        \"\"\"\n        Test SMTP connection and credentials\n        \"\"\"\n        result = {\n            'success': False,\n            'error': None\n        }\n        \n        try:\n            context = ssl.create_default_context()\n            \n            with smtplib.SMTP(self.smtp_server, self.smtp_port) as server:\n                server.starttls(context=context)\n                server.login(self.email, self.password)\n                \n                result['success'] = True\n                \n        except smtplib.SMTPAuthenticationError:\n            result['error'] = \"Authentication failed. Check your email and password.\"\n        except smtplib.SMTPConnectError:\n            result['error'] = f\"Cannot connect to SMTP server {self.smtp_server}:{self.smtp_port}\"\n        except Exception as e:\n            result['error'] = f\"Connection test failed: {str(e)}\"\n        \n        return result\n\nclass EmailTemplate:\n    \"\"\"\n    Simple email template system\n    \"\"\"\n    \n    @staticmethod\n    def create_welcome_template(name: str, company: str) -> str:\n        return f\"\"\"\n        <html>\n        <body>\n        <h2>Welcome {name}!</h2>\n        <p>Thank you for joining {company}. We're excited to have you on board!</p>\n        <p>If you have any questions, please don't hesitate to reach out.</p>\n        <br>\n        <p>Best regards,<br>The {company} Team</p>\n        </body>\n        </html>\n        \"\"\"\n    \n    @staticmethod\n    def create_newsletter_template(title: str, content: str, unsubscribe_link: str) -> str:\n        return f\"\"\"\n        <html>\n        <body>\n        <h1>{title}</h1>\n        <div>{content}</div>\n        <hr>\n        <p><small>\n        Don't want to receive these emails? \n        <a href=\"{unsubscribe_link}\">Unsubscribe here</a>\n        </small></p>\n        </body>\n        </html>\n        \"\"\"\n    \n    @staticmethod\n    def create_notification_template(subject: str, message: str, action_url: Optional[str] = None) -> str:\n        template = f\"\"\"\n        <html>\n        <body>\n        <h2>{subject}</h2>\n        <p>{message}</p>\n        \"\"\"\n        \n        if action_url:\n            template += f'<p><a href=\"{action_url}\" style=\"background-color: #4CAF50; color: white; padding: 10px 20px; text-decoration: none; border-radius: 5px;\">Take Action</a></p>'\n        \n        template += \"\"\"\n        </body>\n        </html>\n        \"\"\"\n        \n        return template\n","size_bytes":6586},"utils/email_validator.py":{"content":"import re\nimport dns.resolver\nimport smtplib\nimport socket\nfrom email_validator import validate_email, EmailNotValidError\nfrom typing import Dict, List\nimport time\n\nclass EmailValidator:\n    def __init__(self):\n        self.mx_cache = {}\n        self.smtp_timeout = 10\n        \n    def validate_single_email(self, email: str) -> Dict:\n        \"\"\"\n        Validate a single email address with comprehensive checks\n        \"\"\"\n        result = {\n            'email': email,\n            'is_valid': False,\n            'confidence': 0.0,\n            'syntax_valid': False,\n            'domain_valid': False,\n            'mx_valid': False,\n            'smtp_valid': False,\n            'error': None\n        }\n        \n        try:\n            # Step 1: Syntax validation using email-validator\n            try:\n                valid_email = validate_email(email)\n                result['syntax_valid'] = True\n                result['confidence'] += 25\n                email = valid_email.email\n            except EmailNotValidError as e:\n                result['error'] = f\"Syntax error: {str(e)}\"\n                return result\n            \n            # Step 2: Domain existence check\n            domain = email.split('@')[1]\n            if self._check_domain_exists(domain):\n                result['domain_valid'] = True\n                result['confidence'] += 25\n            else:\n                result['error'] = \"Domain does not exist\"\n                return result\n            \n            # Step 3: MX record check\n            mx_records = self._get_mx_records(domain)\n            if mx_records:\n                result['mx_valid'] = True\n                result['confidence'] += 25\n            else:\n                result['error'] = \"No MX records found\"\n                result['confidence'] += 10  # Domain exists but no MX\n            \n            # Step 4: SMTP verification (optional, can be slow)\n            if mx_records:\n                smtp_result = self._check_smtp_deliverability(email, mx_records[0])\n                if smtp_result['valid']:\n                    result['smtp_valid'] = True\n                    result['confidence'] += 25\n                elif smtp_result['error']:\n                    result['error'] = f\"SMTP check: {smtp_result['error']}\"\n                    result['confidence'] += 10  # Inconclusive\n            \n            # Final validation decision - SMTP verification must pass for email to be valid\n            if result['smtp_valid']:\n                result['is_valid'] = True\n            else:\n                result['is_valid'] = False\n            \n        except Exception as e:\n            result['error'] = f\"Validation error: {str(e)}\"\n        \n        return result\n    \n    def _check_domain_exists(self, domain: str) -> bool:\n        \"\"\"Check if domain exists via DNS lookup\"\"\"\n        try:\n            dns.resolver.resolve(domain, 'A')\n            return True\n        except (dns.resolver.NXDOMAIN, dns.resolver.NoAnswer, Exception):\n            try:\n                # Try AAAA record for IPv6\n                dns.resolver.resolve(domain, 'AAAA')\n                return True\n            except:\n                return False\n    \n    def _get_mx_records(self, domain: str) -> List[str]:\n        \"\"\"Get MX records for domain\"\"\"\n        if domain in self.mx_cache:\n            return self.mx_cache[domain]\n        \n        try:\n            mx_records = dns.resolver.resolve(domain, 'MX')\n            # Sort by preference and get exchange hostnames\n            sorted_mx = sorted(mx_records, key=lambda x: getattr(x, 'preference', 0))\n            mx_list = [str(getattr(mx, 'exchange', mx)).rstrip('.') for mx in sorted_mx]\n            self.mx_cache[domain] = mx_list\n            return mx_list\n        except (dns.resolver.NXDOMAIN, dns.resolver.NoAnswer, Exception):\n            self.mx_cache[domain] = []\n            return []\n    \n    def _check_smtp_deliverability(self, email: str, mx_server: str) -> Dict:\n        \"\"\"Check if email exists via SMTP verification\"\"\"\n        result = {'valid': False, 'error': None}\n        \n        try:\n            # Connect to SMTP server\n            server = smtplib.SMTP(timeout=self.smtp_timeout)\n            server.connect(mx_server, 25)\n            server.helo('example.com')\n            \n            # Try to start mail transaction\n            code, message = server.mail('test@example.com')\n            if code != 250:\n                result['error'] = f\"MAIL command failed: {message}\"\n                server.quit()\n                return result\n            \n            # Check if recipient exists\n            code, message = server.rcpt(email)\n            server.quit()\n            \n            if code == 250:\n                result['valid'] = True\n            elif code in [450, 451, 452]:\n                result['error'] = \"Temporary failure, mailbox may exist\"\n            elif code in [550, 551, 552, 553]:\n                result['error'] = \"Mailbox does not exist or rejected\"\n            else:\n                result['error'] = f\"SMTP error {code}: {message}\"\n                \n        except socket.timeout:\n            result['error'] = \"SMTP connection timeout\"\n        except socket.gaierror:\n            result['error'] = \"Cannot connect to mail server\"\n        except smtplib.SMTPConnectError:\n            result['error'] = \"Cannot connect to SMTP server\"\n        except smtplib.SMTPServerDisconnected:\n            result['error'] = \"SMTP server disconnected\"\n        except Exception as e:\n            result['error'] = f\"SMTP check failed: {str(e)}\"\n        \n        return result\n    \n    def validate_bulk_emails(self, emails: List[str], progress_callback=None) -> List[Dict]:\n        \"\"\"Validate multiple emails with progress tracking\"\"\"\n        results = []\n        \n        for i, email in enumerate(emails):\n            result = self.validate_single_email(email)\n            results.append(result)\n            \n            if progress_callback:\n                progress_callback(i + 1, len(emails), email)\n            \n            # Small delay to avoid overwhelming servers\n            time.sleep(0.1)\n        \n        return results\n","size_bytes":6151},"utils/scheduler.py":{"content":"import json\nimport os\nfrom datetime import datetime, timedelta\nimport pandas as pd\nfrom typing import Dict, List, Optional\nimport uuid\nimport threading\nimport time\nfrom utils.email_sender import EmailSender\n\nclass EmailScheduler:\n    def __init__(self):\n        self.jobs_file = \"scheduled_jobs.json\"\n        self.jobs = self._load_jobs()\n        self.running = False\n        self._start_scheduler_thread()\n    \n    def _load_jobs(self) -> List[Dict]:\n        \"\"\"Load scheduled jobs from file\"\"\"\n        if os.path.exists(self.jobs_file):\n            try:\n                with open(self.jobs_file, 'r') as f:\n                    return json.load(f)\n            except (json.JSONDecodeError, FileNotFoundError):\n                return []\n        return []\n    \n    def _save_jobs(self):\n        \"\"\"Save jobs to file\"\"\"\n        with open(self.jobs_file, 'w') as f:\n            json.dump(self.jobs, f, indent=2, default=str)\n    \n    def schedule_email(self, recipients: List[str], subject: str, message: str, \n                      scheduled_time: pd.Timestamp, credentials: Dict, \n                      is_html: bool = False) -> str:\n        \"\"\"\n        Schedule an email to be sent at a specific time\n        \"\"\"\n        job_id = str(uuid.uuid4())[:8]\n        \n        job = {\n            'id': job_id,\n            'recipients': recipients,\n            'subject': subject,\n            'message': message,\n            'scheduled_time': scheduled_time.isoformat(),\n            'credentials': credentials,\n            'is_html': is_html,\n            'status': 'pending',\n            'created_time': datetime.now().isoformat(),\n            'sent_time': None,\n            'success_count': 0,\n            'total_count': len(recipients),\n            'results': []\n        }\n        \n        self.jobs.append(job)\n        self._save_jobs()\n        \n        return job_id\n    \n    def get_scheduled_jobs(self) -> List[Dict]:\n        \"\"\"Get all scheduled jobs\"\"\"\n        # Reload from file to get latest status\n        self.jobs = self._load_jobs()\n        return self.jobs\n    \n    def cancel_job(self, job_id: str) -> bool:\n        \"\"\"Cancel a scheduled job\"\"\"\n        for job in self.jobs:\n            if job['id'] == job_id and job['status'] == 'pending':\n                job['status'] = 'cancelled'\n                self._save_jobs()\n                return True\n        return False\n    \n    def clear_completed_jobs(self):\n        \"\"\"Remove completed and cancelled jobs\"\"\"\n        self.jobs = [job for job in self.jobs if job['status'] in ['pending', 'sending']]\n        self._save_jobs()\n    \n    def _start_scheduler_thread(self):\n        \"\"\"Start the background scheduler thread\"\"\"\n        if not self.running:\n            self.running = True\n            thread = threading.Thread(target=self._scheduler_loop, daemon=True)\n            thread.start()\n    \n    def _scheduler_loop(self):\n        \"\"\"Main scheduler loop - runs in background thread\"\"\"\n        while self.running:\n            try:\n                current_time = datetime.now()\n                self.jobs = self._load_jobs()  # Reload from file\n                \n                for job in self.jobs:\n                    if job['status'] == 'pending':\n                        scheduled_time = pd.Timestamp(job['scheduled_time']).to_pydatetime()\n                        \n                        if current_time >= scheduled_time:\n                            self._execute_job(job)\n                \n                # Check every 30 seconds\n                time.sleep(30)\n                \n            except Exception as e:\n                print(f\"Scheduler error: {str(e)}\")\n                time.sleep(60)  # Wait longer on error\n    \n    def _execute_job(self, job: Dict):\n        \"\"\"Execute a scheduled email job\"\"\"\n        try:\n            job['status'] = 'sending'\n            self._save_jobs()\n            \n            # Create email sender\n            sender = EmailSender(job['credentials'])\n            \n            # Send emails\n            results = sender.send_bulk_email(\n                job['recipients'],\n                job['subject'],\n                job['message'],\n                job['is_html']\n            )\n            \n            # Update job status\n            successful_sends = sum(1 for r in results if r['success'])\n            \n            job['status'] = 'completed'\n            job['sent_time'] = datetime.now().isoformat()\n            job['success_count'] = successful_sends\n            job['results'] = results\n            \n            self._save_jobs()\n            \n        except Exception as e:\n            job['status'] = 'failed'\n            job['error'] = str(e)\n            job['sent_time'] = datetime.now().isoformat()\n            self._save_jobs()\n\n# Global scheduler instance\n_scheduler_instance = None\n\ndef get_scheduler() -> EmailScheduler:\n    \"\"\"Get global scheduler instance\"\"\"\n    global _scheduler_instance\n    if _scheduler_instance is None:\n        _scheduler_instance = EmailScheduler()\n    return _scheduler_instance\n","size_bytes":5026}},"version":1}